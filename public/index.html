<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://bitcoincore.tech/apps/bitcoinjs-ui/lib/bitcoinjs-lib.js"></script>
  <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
  <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
</head>
<body>
  <script>
    // Define some useful libraries and functions.
    var { getSharedSecret, schnorr, utils } = nobleSecp256k1
    var crypto  = window.crypto 
    var getRand = size => crypto.getRandomValues(new Uint8Array(size))
    var sha256  = bitcoinjs.crypto.sha256

    // Generate a key-pair for digital signatures.
		var keypair = bitcoinjs.ECPair.makeRandom()
		var privKey = keypair.privateKey.toString( "hex" )
		var pubKey  = keypair.publicKey.toString( "hex" ).substring( 2 )

    // Configure a new websocket connection.
    var relay   = "wss://nostr-relay.wlvs.space"
    var socket  = new WebSocket( relay )

    // Configure our subscription settings.
    var subId   = crypto.randomUUID()
    var filter  = { "authors": [ pubKey ] }

    async function getSignedEvent(event, privateKey) {
      /** Produce a signed hash of our event, attach it
       *  to the event object, then serialize the result.
       */
      var eventData = JSON.stringify([
        0,		                // this is reserved for future use
        event['pubkey'],	    // yours, not someone else’s
        event['created_at'],  // unix timestamp
        event['kind'],		    // message “kind” – public notes are kind 1
        event['tags'],		    // tags – identify replies or recipients
        event['content']      // your noteS
      ])

      event.id  = sha256( eventData ).toString( 'hex' )
      event.sig = await schnorr.sign( event.id, privateKey )
      
      return event
    }

    socket.addEventListener('open', async function( event ) {
      // Log to console once we have an open connection. 
      console.log( "connected to " + relay )
      
      // Craft our subscription request.
      var subscription = [ "REQ", subId, filter ]
      console.log('Subscription:', subscription)

      socket.send(JSON.stringify( subscription ));

      // Craft our event message.
      var event = {
        "content"    : "this workshop is awesome!",
        "created_at" : Math.floor( Date.now() / 1000 ),
        "kind"       : 1,
        "tags"       : [],
        "pubkey"     : pubKey,
      }

      // Sign our message.
      var signedEvent = await getSignedEvent(event, privKey)
      console.log('signedEvent:', signedEvent)

      socket.send(JSON.stringify([ "EVENT", signedEvent ]))

      // BONUS: Send an encrypted message!
		  var keypair2 = bitcoinjs.ECPair.makeRandom()
		  var privKey2 = keypair2.privateKey.toString( "hex" )
		  var pubKey2  = keypair2.publicKey.toString( "hex" ).substring( 2 )

      var shareKey1 = await getSharedKey(privKey, pubKey2)
      var shareKey2 = await getSharedKey(privKey2, pubKey)
      var msg = "this message is super secret!"
      var encrypted = await encrypt(msg, shareKey1)

      console.log(encrypted)

      var event2 = {
        "content"    : encrypted,
        "created_at" : Math.floor( Date.now() / 1000 ),
        "kind"       : 4,
        "tags"       : [ [ 'p', pubKey2 ] ],
        "pubkey"     : pubKey,
      }

      // Sign our message.
      var signedEvent2 = await getSignedEvent(event2, privKey)
      console.log('signedEvent2:', signedEvent2)

      socket.send(JSON.stringify([ "EVENT", signedEvent ]))

    });

    socket.addEventListener( 'message', function( message ) {
      var [ type, subId, event ] = JSON.parse( message.data );
      var { kind, content } = event || {}

      console.log('message:', event)

      if (kind === 4) {
        content = decrypt(content, shareKey2)
      }

      console.log(content)
    })

    // EXTRA: END-TO-END Encryption!

    async function getSharedKey(privkey, pubkey) {
      var key = getSharedSecret(privkey, '02' + pubkey, true).substring(2)
      var options = { name: 'AES-CBC' }
      var usage   = [ 'encrypt', 'decrypt' ]
      return crypto.subtle.importKey('raw', hexToBytes(key), options, true, usage)
    }
    
    async function encrypt(message, keyFile ) {
      var iv = crypto.getRandomValues( new Uint8Array(16) )
      var ec = new TextEncoder()
      var msg = ec.encode(message)

      var cipherText = await crypto.subtle.encrypt({ name: 'AES-CBC', iv }, keyFile, msg)

      console.log(keyFile, ec.encode(message), cipherText)


      return bytesToBase64(cipherText) + '?iv=' + bytesToBase64(iv)
    }
    
    async function decrypt(encodedText, keyFile) {
      /* Decrypt a string using the symmetric encryption key. */
      var [ cipherText, iv ] = encodedText.split('?iv=')
      var byteArray  = hexToBtyes(btoa(encodedText))
      var cipherText = byteArray.slice(16, byteArray.byteLength + 1)
      var iv = byteArray.slice(0, 16)
      var dc = new TextDecoder()
      
      console.log('test', cipherText, iv)
      var plainText = await crypto.subtle.decrypt(
        { name: 'AES-CBC', iv: base64ToBytes(iv) }, 
        keyFile, 
        base64ToBytes(cipherText)
      )

      console.log(plainText)
      
      return dc.decode(plainText)
    }

    function bytesToHex(byteArray) {
      return Array
        .from(byteArray)
        .map((byte) => (byte & 0xff).toString(16).padStart(2, '0'))
        .join('')
    }

    function hexToBytes(str) {
	    for (var arr = [], i = 0; i < str.length; i += 2) {
	      arr.push(parseInt(str.substr(i, 2), 16))
	    }
      return Uint8Array.from(arr)
    }

    function bytesToBase64(byteArray) {
      console.log(byteArray)
      return Array
        .from(byteArray)
        .map((byte) => String.fromCharCode(byte))
        .join('')
    }

    function base64ToBytes(str) {
      return new Uint8Array([ ...atob(str) ].map(c => c.charCodeAt(0)))
    }
  </script>
</body>
</html>